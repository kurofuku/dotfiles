diff --git a/clamonacc/client/client.c b/clamonacc/client/client.c
index 4e627944a..41380c50d 100644
--- a/clamonacc/client/client.c
+++ b/clamonacc/client/client.c
@@ -529,7 +529,7 @@ int onas_get_clamd_version(struct onas_context **ctx)
  * @param err       return variable passed to the daemon protocol interface indicating how many things went wrong in the course of scanning
  * @param ret_code  return variable passed to the daemon protocol interface indicating last known issue or success
  */
-int onas_client_scan(const char *tcpaddr, int64_t portnum, int32_t scantype, uint64_t maxstream, const char *fname, int fd, int64_t timeout, STATBUF sb, int *infected, int *err, cl_error_t *ret_code)
+int onas_client_scan(const char *tcpaddr, int64_t portnum, int32_t scantype, uint64_t maxstream, const char *fname, int fd, int64_t timeout, struct onas_context *ctx, STATBUF sb, int *infected, int *err, cl_error_t *ret_code)
 {
     CURL *curl        = NULL;
     CURLcode curlcode = CURLE_OK;
@@ -564,7 +564,7 @@ int onas_client_scan(const char *tcpaddr, int64_t portnum, int32_t scantype, uin
         disconnected = false;
     }
 
-    if ((ret = onas_dsresult(curl, scantype, maxstream, fname, fd, timeout, &ret, err, ret_code)) >= 0) {
+    if ((ret = onas_dsresult(curl, scantype, maxstream, fname, fd, timeout, ctx, &ret, err, ret_code)) >= 0) {
         *infected = ret;
     } else {
         logg(LOGG_DEBUG, "ClamClient: connection could not be established ... return code %d\n", *ret_code);
diff --git a/clamonacc/client/client.h b/clamonacc/client/client.h
index bd4668f56..4593ffa5a 100644
--- a/clamonacc/client/client.h
+++ b/clamonacc/client/client.h
@@ -31,7 +31,7 @@
 #define ONAS_DEFAULT_PING_ATTEMPTS 31
 
 void onas_print_server_version(struct onas_context **ctx);
-int onas_client_scan(const char *tcpaddr, int64_t portnum, int32_t scantype, uint64_t maxstream, const char *fname, int fd, int64_t timeout, STATBUF sb, int *infected, int *err, cl_error_t *ret_code);
+int onas_client_scan(const char *tcpaddr, int64_t portnum, int32_t scantype, uint64_t maxstream, const char *fname, int fd, int64_t timeout, struct onas_context *ctx, STATBUF sb, int *infected, int *err, cl_error_t *ret_code);
 CURLcode onas_curl_init(CURL **curl, const char *ipaddr, int64_t port, int64_t timeout);
 int onas_get_clamd_version(struct onas_context **ctx);
 cl_error_t onas_setup_client(struct onas_context **ctx);
diff --git a/clamonacc/client/protocol.c b/clamonacc/client/protocol.c
index b307007cb..3c0b314ad 100644
--- a/clamonacc/client/protocol.c
+++ b/clamonacc/client/protocol.c
@@ -228,11 +228,111 @@ fd_out:
 }
 #endif
 
+static pthread_mutex_t virusaction_lock = PTHREAD_MUTEX_INITIALIZER;
+
+static void xfree(void *p)
+{
+    if (p)
+        free(p);
+}
+
+#define VE_FILENAME "CLAM_VIRUSEVENT_FILENAME"
+#define VE_VIRUSNAME "CLAM_VIRUSEVENT_VIRUSNAME"
+
+void virusaction(const char *filename, const char *virname,
+                 const struct optstruct *opts)
+{
+    pid_t pid;
+    const struct optstruct *opt;
+    char *buffer_file, *buffer_vir, *buffer_cmd, *path;
+    const char *pt;
+    size_t i, j, v = 0, f = 0, len;
+    char *env[4];
+
+    if (!(opt = optget(opts, "OnAccessVirusEvent")) || !opt->enabled) {
+        logg(LOGG_WARNING, "*OnAccessVirusEvent not found\n");
+        return;
+    }
+
+    path   = getenv("PATH");
+    env[0] = path ? strdup(path) : NULL;
+    j      = env[0] ? 1 : 0;
+    /* Allocate env vars.. to be portable env vars should not be freed */
+    buffer_file =
+        (char *)malloc(strlen(VE_FILENAME) + strlen(filename) + 2);
+    if (buffer_file) {
+        sprintf(buffer_file, "%s=%s", VE_FILENAME, filename);
+        env[j++] = buffer_file;
+    }
+
+    buffer_vir =
+        (char *)malloc(strlen(VE_VIRUSNAME) + strlen(virname) + 2);
+    if (buffer_vir) {
+        sprintf(buffer_vir, "%s=%s", VE_VIRUSNAME, virname);
+        env[j++] = buffer_vir;
+    }
+    env[j++] = NULL;
+
+    pt = opt->strarg;
+    while ((pt = strstr(pt, "%v"))) {
+        pt += 2;
+        v++;
+    }
+    pt = opt->strarg;
+    while ((pt = strstr(pt, "%f"))) {
+        pt += 2;
+        f++;
+    }
+    len = strlen(opt->strarg);
+    buffer_cmd =
+        (char *)calloc(len + v * strlen(virname) + f * strlen(filename) + 1, sizeof(char));
+    if (!buffer_cmd) {
+        if (path)
+            xfree(env[0]);
+
+        xfree(buffer_file);
+        xfree(buffer_vir);
+        return;
+    }
+    for (i = 0, j = 0; i < len; i++) {
+        if (i + 1 < len && opt->strarg[i] == '%' && opt->strarg[i + 1] == 'v') {
+            strcat(buffer_cmd, virname);
+            j += strlen(virname);
+            i++;
+        } else if (i + 1 < len && opt->strarg[i] == '%' && opt->strarg[i + 1] == 'f') {
+            strcat(buffer_cmd, filename);
+            j += strlen(filename);
+            i++;
+        } else {
+            buffer_cmd[j++] = opt->strarg[i];
+        }
+    }
+
+    pthread_mutex_lock(&virusaction_lock);
+    /* We can only call async-signal-safe functions after fork(). */
+    pid = vfork();
+    if (pid == 0) { /* child */
+        _exit(execle("/bin/sh", "sh", "-c", buffer_cmd, NULL, env));
+    } else if (pid > 0) { /* parent */
+        pthread_mutex_unlock(&virusaction_lock);
+        while (waitpid(pid, NULL, 0) == -1 && errno == EINTR) continue;
+    } else {
+        pthread_mutex_unlock(&virusaction_lock);
+        logg(LOGG_ERROR, "!VirusEvent: fork failed.\n");
+    }
+    if (path)  
+        xfree(env[0]);
+
+    xfree(buffer_cmd);
+    xfree(buffer_file);
+    xfree(buffer_vir);
+}
+
 /* Sends a proper scan request to clamd and parses its replies
  * This is used only in non IDSESSION mode
  * Returns the number of infected files or -1 on error
  * NOTE: filename may be NULL for STREAM scantype. */
-int onas_dsresult(CURL *curl, int scantype, uint64_t maxstream, const char *filename, int fd, int64_t timeout, int *printok, int *errors, cl_error_t *ret_code)
+int onas_dsresult(CURL *curl, int scantype, uint64_t maxstream, const char *filename, int fd, int64_t timeout, struct onas_context *ctx, int *printok, int *errors, cl_error_t *ret_code)
 {
     int infected = 0, len = 0, beenthere = 0;
     char *bol, *eol;
@@ -370,6 +470,7 @@ int onas_dsresult(CURL *curl, int scantype, uint64_t maxstream, const char *file
                         logg(LOGG_INFO, "%s%s FOUND\n", filename, colon);
                         if (action) {
                             action(filename);
+                            virusaction(filename, colon, ctx->clamdopts);
                         }
                     } else {
                         logg(LOGG_INFO, "%s FOUND\n", bol);
diff --git a/clamonacc/client/protocol.h b/clamonacc/client/protocol.h
index 82d596466..92378f07a 100644
--- a/clamonacc/client/protocol.h
+++ b/clamonacc/client/protocol.h
@@ -27,5 +27,5 @@
 #include "misc.h"
 #include "../clamonacc.h"
 
-int onas_dsresult(CURL *curl, int scantype, uint64_t maxstream, const char *filename, int fd, int64_t timeout, int *printok, int *errors, cl_error_t *ret_code);
+int onas_dsresult(CURL *curl, int scantype, uint64_t maxstream, const char *filename, int fd, int64_t timeout, struct onas_context *ctx, int *printok, int *errors, cl_error_t *ret_code);
 #endif
diff --git a/clamonacc/fanotif/fanotif.c b/clamonacc/fanotif/fanotif.c
index d57d7212c..530c687d3 100644
--- a/clamonacc/fanotif/fanotif.c
+++ b/clamonacc/fanotif/fanotif.c
@@ -84,13 +84,13 @@ cl_error_t onas_setup_fanotif(struct onas_context **ctx)
 
     if (optget((*ctx)->clamdopts, "OnAccessPrevention")->enabled && !optget((*ctx)->clamdopts, "OnAccessMountPath")->enabled) {
         logg(LOGG_DEBUG, "ClamFanotif: kernel-level blocking feature enabled ... preventing malicious files access attempts\n");
-        (*ctx)->fan_mask |= FAN_ACCESS_PERM | FAN_OPEN_PERM;
+        (*ctx)->fan_mask |= FAN_MODIFY | FAN_CLOSE | FAN_OPEN_EXEC_PERM;
     } else {
         logg(LOGG_DEBUG, "ClamFanotif: kernel-level blocking feature disabled ...\n");
         if (optget((*ctx)->clamdopts, "OnAccessPrevention")->enabled && optget((*ctx)->clamdopts, "OnAccessMountPath")->enabled) {
             logg(LOGG_DEBUG, "ClamFanotif: feature not available when watching mounts ... \n");
         }
-        (*ctx)->fan_mask |= FAN_ACCESS | FAN_OPEN;
+        (*ctx)->fan_mask |= FAN_MODIFY | FAN_CLOSE | FAN_OPEN_EXEC;
     }
 
     pt_tmpdir = optget((*ctx)->clamdopts, "TemporaryDirectory");
diff --git a/clamonacc/scan/onas_queue.c b/clamonacc/scan/onas_queue.c
index 4b16d0080..304674b48 100644
--- a/clamonacc/scan/onas_queue.c
+++ b/clamonacc/scan/onas_queue.c
@@ -48,7 +48,7 @@
 #include "onas_queue.h"
 
 static void onas_scan_queue_exit(void *arg);
-static int onas_consume_event(threadpool thpool);
+static int onas_consume_event(threadpool thpool, struct onas_context *ctx);
 static cl_error_t onas_new_event_queue_node(struct onas_event_queue_node **node);
 static void onas_destroy_event_queue_node(struct onas_event_queue_node *node);
 
@@ -183,7 +183,7 @@ void *onas_scan_queue_th(void *arg)
     pthread_cleanup_push(onas_scan_queue_exit, NULL);
     logg(LOGG_DEBUG, "ClamScanQueue: waiting to consume events ...\n");
     do {
-        onas_consume_event(thpool);
+        onas_consume_event(thpool, ctx);
     } while (1);
 
     pthread_cleanup_pop(1);
@@ -199,7 +199,7 @@ static int onas_queue_is_b_empty(void)
     return 0;
 }
 
-static int onas_consume_event(threadpool thpool)
+static int onas_consume_event(threadpool thpool, struct onas_context *ctx)
 {
     pthread_mutex_lock(&onas_queue_lock);
 
@@ -212,6 +212,8 @@ static int onas_consume_event(threadpool thpool)
     g_onas_event_queue_head->next->prev       = g_onas_event_queue_head;
     g_onas_event_queue.size--;
 
+    popped_node->data->ctx                    = ctx;
+
     pthread_mutex_unlock(&onas_queue_lock);
 
     thpool_add_work(thpool, (void *)onas_scan_worker, (void *)popped_node->data);
diff --git a/clamonacc/scan/thread.c b/clamonacc/scan/thread.c
index 62cd58b29..9aa4e4459 100644
--- a/clamonacc/scan/thread.c
+++ b/clamonacc/scan/thread.c
@@ -128,7 +128,7 @@ static cl_error_t onas_scan_safe(struct onas_scan_event *event_data, const char
     pthread_mutex_lock(&onas_scan_lock);
 
     ret = onas_client_scan(event_data->tcpaddr, event_data->portnum, event_data->scantype, event_data->maxstream,
-                           fname, fd, event_data->timeout, sb, infected, err, ret_code);
+                           fname, fd, event_data->timeout, event_data->ctx, sb, infected, err, ret_code);
 
     pthread_mutex_unlock(&onas_scan_lock);
 
diff --git a/clamonacc/scan/thread.h b/clamonacc/scan/thread.h
index 199aeaa94..d3bf25178 100644
--- a/clamonacc/scan/thread.h
+++ b/clamonacc/scan/thread.h
@@ -64,6 +64,7 @@ struct onas_scan_event {
     int64_t maxstream;
     int64_t timeout;
     uint8_t bool_opts;
+    struct onas_context *ctx;
 } __attribute((packed));
 
 #ifdef HAVE_PRAGMA_PACK
diff --git a/common/optparser.c b/common/optparser.c
index 219134946..496171abd 100644
--- a/common/optparser.c
+++ b/common/optparser.c
@@ -500,6 +500,8 @@ const struct clam_option __clam_options[] = {
 
     {"OnAccessDenyOnError", NULL, 0, CLOPT_TYPE_BOOL, MATCH_BOOL, 0, NULL, 0, OPT_CLAMD, "When using prevention, if this option is turned on, any errors that occur during scanning will result in the event attempt being denied. This could potentially lead to unwanted system behaviour with certain configurations, so the client defaults to off and allowing access events in case of error.", "yes"},
 
+    {"OnAccessVirusEvent", NULL, 0, CLOPT_TYPE_STRING, NULL, -1, NULL, 0, OPT_CLAMD, "clamonacc executes this command when a virus is found. In the command string %v will be\nreplaced with the virus name and %f will be replaced with the file name.\nAdditionally, two environment variables will be defined: $CLAM_VIRUSEVENT_FILENAME\nand $CLAM_VIRUSEVENT_VIRUSNAME.", "/usr/bin/mailx -s \"ClamAV VIRUS ALERT: %v\" alert < /dev/null"},
+
     /* clamonacc cmdline options */
 
     {NULL, "watch-list", 'W', CLOPT_TYPE_STRING, NULL, -1, NULL, 0, OPT_CLAMONACC, "", ""},
